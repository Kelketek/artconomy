# Generated by Django 3.0.4 on 2020-03-28 12:05
from django.contrib.contenttypes.models import ContentType
from django.db import migrations

# Status types
from short_stuff import slugify

SUCCESS = 0
FAILURE = 1
PENDING = 2

STATUSES = (
    (SUCCESS, "Successful"),
    (FAILURE, "Failed"),
    (PENDING, "Pending"),
)

# Account types
CARD = 300
BANK = 301
ESCROW = 302
HOLDINGS = 303
# All fees put the difference for premium bonus into reserve until an order is complete. When complete, these
# amounts are deposited into either the cash account of Artconomy, or added to the user's holdings.
RESERVE = 304
# Earnings for which we have not yet subtracted card/bank transfer fees.
UNPROCESSED_EARNINGS = 305
# These two fee types will be used to keep track of fees that have been paid out to card processors.
CARD_TRANSACTION_FEES = 306
CARD_MISC_FEES = 307

# Fees from performing ACH transactions
ACH_TRANSACTION_FEES = 308
# Fees for other ACH-related items, like Dwolla's customer onboarding fees.
ACH_MISC_FEES = 309

# Tax held here until order finalized
MONEY_HOLE_STAGE = 310

# Where taxes go
MONEY_HOLE = 311

# For when a customer gives us cash, like at an event.
CASH_DEPOSIT = 407

ACCOUNT_TYPES = (
    (CARD, "Credit Card"),
    (BANK, "Bank Account"),
    (ESCROW, "Escrow"),
    (HOLDINGS, "Finalized Earnings, available for withdraw"),
    (RESERVE, "Contingency reserve"),
    (UNPROCESSED_EARNINGS, "Unannotated earnings"),
    (CARD_TRANSACTION_FEES, "Card transaction fees"),
    (CARD_MISC_FEES, "Other card fees"),
    (CASH_DEPOSIT, "Cash deposit"),
    (ACH_TRANSACTION_FEES, "ACH Transaction fees"),
    (ACH_MISC_FEES, "Other ACH fees"),
    (MONEY_HOLE_STAGE, "Tax staging"),
    (MONEY_HOLE, "Tax"),
)

# Transaction types
SHIELD_FEE = 400
ESCROW_HOLD = 401
ESCROW_RELEASE = 402
ESCROW_REFUND = 403
SUBSCRIPTION_DUES = 404
SUBSCRIPTION_REFUND = 405
CASH_WITHDRAW = 406
THIRD_PARTY_FEE = 408
# The extra money earned for subscribing to premium services and completing a sale.
PREMIUM_BONUS = 409
# 'Catch all' for any transfers between accounts.
INTERNAL_TRANSFER = 410
THIRD_PARTY_REFUND = 411
# For when we make a mistake and need to correct it somehow.
CORRECTION = 412
# For fees levied at conventions
TABLE_HANDLING = 413
TAX = 414
# For things like inventory items sold at tables alongside the commission, like a pop socket.
EXTRA_ITEM = 415
# For times when we're manually sending money to others-- such as cases where we don't yet have code to manage
# something but we need to be able to pay using Dwolla.
MANUAL_PAYOUT = 416

CATEGORIES = (
    (SHIELD_FEE, "Artconomy Service Fee"),
    (ESCROW_HOLD, "Escrow hold"),
    (ESCROW_RELEASE, "Escrow release"),
    (ESCROW_REFUND, "Escrow refund"),
    (SUBSCRIPTION_DUES, "Subscription dues"),
    (SUBSCRIPTION_REFUND, "Refund for subscription dues"),
    (CASH_WITHDRAW, "Cash withdrawal"),
    (THIRD_PARTY_FEE, "Third party fee"),
    (PREMIUM_BONUS, "Premium service bonus"),
    (INTERNAL_TRANSFER, "Internal Transfer"),
    (THIRD_PARTY_REFUND, "Third party refund"),
    (CORRECTION, "Correction"),
    (TAX, "Tax"),
    (MANUAL_PAYOUT, "Manual Payout"),
)

# Order status
COMPLETED = 8


def annotate_payouts(apps, schema):
    GenericReference = apps.get_model("lib", "GenericReference")
    Order = apps.get_model("sales", "Order")
    TransactionRecord = apps.get_model("sales", "TransactionRecord")
    order_content_type_id = ContentType.objects.get_for_model(Order).id

    def ref_for_instance(object_id: int, content_type_id: int):
        result, _created = GenericReference.objects.get_or_create(
            content_type_id=content_type_id,
            object_id=object_id,
        )
        return result

    user_ids = (
        TransactionRecord.objects.filter(
            status=SUCCESS, category=CASH_WITHDRAW, source=HOLDINGS
        )
        .values_list(
            "payee",
            flat=True,
        )
        .distinct()
    )
    for user_id in user_ids:
        references = [
            ref_for_instance(sale.id, order_content_type_id)
            for sale in Order.objects.filter(
                seller_id=user_id, status=COMPLETED, escrow_disabled=False
            )
        ]
        transactions = TransactionRecord.objects.filter(
            targets__in=references,
            source=ESCROW,
            destination=HOLDINGS,
        ).order_by("created_on")
        for transaction in transactions:
            payout_transactions = TransactionRecord.objects.filter(
                payer=transaction.payee,
                source=HOLDINGS,
                destination=BANK,
                status__in=[SUCCESS, PENDING],
                created_on__gte=transaction.created_on.replace(microsecond=0),
            ).order_by("created_on")
            payout_transaction = payout_transactions.first()
            if not payout_transaction:
                continue
            order_targets = transaction.targets.filter(
                content_type_id=order_content_type_id
            )
            payout_transaction.targets.add(*order_targets)
            for target in order_targets:
                order = Order.objects.get(id=target.object_id)
                order.payout_sent = True
                order.save()


def clear_payouts(apps, schema):
    Order = apps.get_model("sales", "Order")
    content_type_id = ContentType.objects.get_for_model(Order).id
    TransactionRecord = apps.get_model("sales", "TransactionRecord")
    TransactionRecord.targets.through.objects.filter(
        transactionrecord__category=CASH_WITHDRAW,
        transactionrecord__status=SUCCESS,
        transactionrecord__source=HOLDINGS,
        genericreference__content_type_id=content_type_id,
    ).delete()
    Order.objects.all().update(payout_sent=False)


class Migration(migrations.Migration):
    dependencies = [
        ("sales", "0085_auto_20200326_1050"),
    ]

    operations = [migrations.RunPython(annotate_payouts, reverse_code=clear_payouts)]
