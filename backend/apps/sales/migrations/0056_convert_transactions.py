# Generated by Django 2.2.1 on 2019-10-17 19:04
from decimal import Decimal
from enum import Enum

from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.db import migrations
from django.db.models import Sum
from django.utils import timezone
from moneyed import Money


class Old:
    SUCCESS = 0
    FAILURE = 1

    CARD = 100
    ACH = 101
    ESCROW = 102
    ACCOUNT = 103

    SALE = 200
    DISBURSEMENT_SENT = 201
    DISBURSEMENT_RETURNED = 202
    REFUND = 204
    TRANSFER = 205


class New:
    # Status types
    SUCCESS = 0
    FAILURE = 1
    PENDING = 2

    # Account types
    CARD = 300
    BANK = 301
    ESCROW = 302
    HOLDINGS = 303
    # All fees put the difference for premium bonus into reserve until an order is complete. When complete, these
    # amounts are deposited into either the cash account of Artconomy, or added to the user's holdings.
    RESERVE = 304
    # Earnings for which we have not yet subtracted card/bank transfer fees.
    UNPROCESSED_EARNINGS = 305
    # These two fee types will be used to keep track of fees that have been paid out to card processors.
    CARD_TRANSACTION_FEES = 306
    CARD_MISC_FEES = 307
    # Fees from performing ACH transactions
    ACH_TRANSACTION_FEES = 307
    # Fees for other ACH-related items, like Dwolla's customer onboarding fees.
    ACH_MISC_FEES = 308

    # Transaction types
    SERVICE_FEE = 400
    ESCROW_HOLD = 401
    ESCROW_RELEASE = 402
    ESCROW_REFUND = 403
    SUBSCRIPTION_DUES = 404
    SUBSCRIPTION_REFUND = 405
    CASH_WITHDRAW = 406
    CASH_DEPOSIT = 407
    THIRD_PARTY_FEE = 408
    # The extra money earned for subscribing to premium services and completing a sale.
    PREMIUM_BONUS = 409
    # 'Catch all' for any transfers between accounts.
    INTERNAL_TRANSFER = 410
    THIRD_PARTY_REFUND = 411


# TODO: account for future Dwolla fees as pending transactions, verify existing ones are pulled from the right place,
# allow for import of old card fees, and then make sure these outbound transactions from the old bank are accounted for:
# December 26, 2018: $19.59
# December 28, 2018: $5.50
def run_conversion(apps, schema):
    User = apps.get_model("profiles.User")
    TransactionRecord = apps.get_model("sales.TransactionRecord")
    PaymentRecord = apps.get_model("sales.PaymentRecord")
    Order = apps.get_model("sales.Order")
    BankAccount = apps.get_model("sales.BankAccount")
    # First set of transactions: These are all the transactions used for orders in order to pay into escrow.
    order_type_id = ContentType.objects.get_for_model(Order).id
    user_type_id = ContentType.objects.get_for_model(User).id
    bank_type_id = ContentType.objects.get_for_model(BankAccount).id

    def one_time_events():
        opening_date = timezone.now().replace(month=11, day=27, year=2018)
        TransactionRecord.objects.create(
            payer=None,
            payee=None,
            category=New.CASH_DEPOSIT,
            source=New.BANK,
            destination=New.HOLDINGS,
            amount=Decimal("2000.00"),
            created_on=opening_date,
            status=New.SUCCESS,
            note="Initial cushion deposit",
            finalized_on=opening_date,
        )
        TransactionRecord.objects.create(
            payer=None,
            payee=None,
            source=New.ACH_MISC_FEES,
            destination=New.HOLDINGS,
            category=New.THIRD_PARTY_REFUND,
            amount=Decimal("15.00"),
            created_on=timezone.now().replace(month=10, day=15, year=2019),
            finalized_on=opening_date,
            status=New.SUCCESS,
            note="Dwolla refund for inaccurate charges",
        )

        card_fee_events = [
            (Decimal("27.64"), timezone.now().replace(month=10, day=1, year=2019)),
            (Decimal("28.79"), timezone.now().replace(month=9, day=3, year=2019)),
            (Decimal("34.45"), timezone.now().replace(month=8, day=1, year=2019)),
            (Decimal("28.43"), timezone.now().replace(month=7, day=1, year=2019)),
            (Decimal("29.15"), timezone.now().replace(month=6, day=3, year=2019)),
            (Decimal("34.11"), timezone.now().replace(month=5, day=1, year=2019)),
            (Decimal("49.59"), timezone.now().replace(month=4, day=1, year=2019)),
            (Decimal("56.37"), timezone.now().replace(month=3, day=1, year=2019)),
            (Decimal("52.84"), timezone.now().replace(month=2, day=1, year=2019)),
            (Decimal("56.39"), timezone.now().replace(month=1, day=2, year=2019)),
            (Decimal("48.50"), timezone.now().replace(month=12, day=3, year=2018)),
            (Decimal("24.57"), timezone.now().replace(month=11, day=2, year=2018)),
            (Decimal("53.10"), timezone.now().replace(month=10, day=1, year=2018)),
            (Decimal("54.93"), timezone.now().replace(month=9, day=4, year=2018)),
        ]
        for amount, event_time in card_fee_events:
            TransactionRecord.objects.create(
                payer=None,
                payee=None,
                source=New.HOLDINGS,
                destination=New.CARD_MISC_FEES,
                category=New.THIRD_PARTY_FEE,
                created_on=event_time,
                finalized_on=event_time,
                status=New.SUCCESS,
            )
        deposit_events = [
            (Decimal("34.11"), timezone.now().replace(month=5, day=30, year=2019)),
            (Decimal("49.59"), timezone.now().replace(month=4, day=16, year=2019)),
            (Decimal("112.74"), timezone.now().replace(month=3, day=8, year=2019)),
            (Decimal("52.84"), timezone.now().replace(month=2, day=4, year=2019)),
            (Decimal("56.39"), timezone.now().replace(month=1, day=7, year=2019)),
        ]
        for amount, event_time in deposit_events:
            TransactionRecord.objects.create(
                payer=None,
                payee=None,
                category=New.CASH_DEPOSIT,
                source=New.BANK,
                destination=New.HOLDINGS,
                status=New.SUCCESS,
                amount=amount,
                created_on=event_time,
                finalized_on=event_time,
                note="Deposit to offset fees.",
            )
        # Erroneous transfer.
        error_time = timezone.now().replace(month=3, day=4, year=2019)
        TransactionRecord.objects.create(
            payer=None,
            payee=None,
            source=New.HOLDINGS,
            destination=New.BANK,
            category=New.CASH_WITHDRAW,
            status=New.SUCCESS,
            amount=Decimal("56.37"),
            created_on=error_time,
            finalized_on=error_time,
            note="Erroneous transfer, transferring back.",
        )
        # Now, let's zero out all events prior to this since we changed accounts.
        credit = TransactionRecord.objects.filter(
            created_on__lt=opening_date,
            destination=New.BANK,
        ).aggregate(total=Sum("amount"))["total"] or Decimal("0.00")
        debit = TransactionRecord.objects.filter(
            created_on__lt=opening_date,
            source=New.BANK,
        ).aggregate(total=Sum("amount"))["total"] or Decimal("0.00")
        total = credit + debit
        if total < Decimal("0.00"):
            TransactionRecord.objects.create(
                payer=None,
                payee=None,
                category=New.CASH_DEPOSIT,
                source=New.BANK,
                destination=New.HOLDINGS,
                status=New.SUCCESS,
                amount=total,
                created_on=opening_date,
                finalized_on=opening_date,
                note="Transferring from one bank account to another, and zeroing out the difference.",
            )

    def convert_bank_connection_fees(records):
        for record in records:
            TransactionRecord.objects.create(
                status=New.SUCCESS,
                payer=record.payer,
                payee=None,
                source=New.HOLDINGS,
                destination=New.ACH_MISC_FEES,
                amount=record.amount,
                note=record.note,
                object_id=record.object_id,
                content_type_id=record.content_type_id,
                category=New.THIRD_PARTY_FEE,
                created_on=record.created_on,
            )

    def convert_disbursements(records):
        for record in records:
            if record.finalized:
                status = record.status
            else:
                status = New.PENDING
            TransactionRecord.objects.create(
                payer=record.payer,
                payee=record.payer,
                source=New.HOLDINGS,
                destination=New.BANK,
                object_id=record.object_id,
                category=New.CASH_WITHDRAW,
                content_type_id=record.content_type_id,
                created_on=record.created_on,
                amount=record.amount,
                remote_id=record.txn_id,
                response_message=record.response_message,
                status=status,
                finalized_on=record.created_on if status == New.SUCCESS else None,
                note="Finalized on date may be inaccurate due to missing data during conversion.",
            )
            amount = record.amount.amount * Decimal(".005")
            if amount < Decimal(".05"):
                amount = Decimal(".05")
            elif amount > Decimal("5"):
                amount = Decimal("5.00")
            TransactionRecord.objects.create(
                payer=None,
                payee=None,
                amount=amount,
                source=New.BANK,
                destination=New.ACH_TRANSACTION_FEES,
                category=New.THIRD_PARTY_FEE,
                status=New.SUCCESS,
                created_on=record.created_on,
            )

    def convert_service_dues(records):
        for record in records:
            TransactionRecord.objects.create(
                payer=record.payer,
                payee=record.payee,
                category=New.SUBSCRIPTION_DUES,
                source=New.CARD,
                destination=New.UNPROCESSED_EARNINGS,
                status=record.status,
                remote_id=record.txn_id,
                amount=record.amount,
                response_message=record.response_message,
                card=record.card,
            )

    def convert_failed_refunds(records):
        for record in records:
            order = Order.objects.get(
                id=record.object_id,
            )
            TransactionRecord.objects.create(
                payer=order.seller,
                payee=record.payer,
                category=New.ESCROW_REFUND,
                source=New.HOLDINGS,
                destination=New.CARD,
                remote_id=record.txn_id,
                amount=record.amount,
                status=New.FAILURE,
                object_id=record.object_id,
                content_type_id=order_type_id,
                created_on=record.created_on,
                finalized_on=record.created_on,
                card=record.card,
                response_message=record.response_message,
            )

    def build_refund(
        record, refund, difference, reserve_amount, full_fee_amount, hold_amount
    ):
        fee = PaymentRecord.objects.get(
            status=Old.SUCCESS,
            object_id=record.object_id,
            content_type_id=order_type_id,
            payer=record.escrow_for,
            payee=None,
            type=Old.TRANSFER,
        )
        if fee.amount == full_fee_amount:
            cut = TransactionRecord.objects.create(
                payer=None,
                payee=None,
                category=New.SERVICE_FEE,
                source=New.RESERVE,
                destination=New.UNPROCESSED_EARNINGS,
                remote_id=refund.txn_id,
                amount=reserve_amount,
                status=New.SUCCESS,
                object_id=record.object_id,
                content_type_id=order_type_id,
                created_on=refund.created_on,
                finalized_on=refund.created_on,
                card=record.card,
                response_message=refund.response_message,
            )
        elif (fee.amount + reserve_amount) == full_fee_amount:
            # Used to be that we'd send the difference back to the buyer.
            cut = TransactionRecord.objects.create(
                payer=None,
                payee=record.payer,
                category=New.ESCROW_REFUND,
                source=New.RESERVE,
                destination=New.CARD,
                remote_id=refund.txn_id,
                amount=reserve_amount,
                status=New.SUCCESS,
                object_id=record.object_id,
                content_type_id=order_type_id,
                created_on=refund.created_on,
                finalized_on=refund.created_on,
                card=record.card,
                response_message=refund.response_message,
            )
        else:
            raise AssertionError(
                f"Refund accounting makes no sense! {fee.amount} + {difference} is not {full_fee_amount}!",
            )
        TransactionRecord.objects.create(
            status=New.SUCCESS,
            payer=record.escrow_for,
            payee=record.payer,
            category=New.ESCROW_REFUND,
            source=New.ESCROW,
            destination=New.CARD,
            remote_id=refund.txn_id,
            object_id=record.object_id,
            content_type_id=order_type_id,
            created_on=refund.created_on,
            finalized_on=refund.created_on,
            card=record.card,
            amount=hold_amount,
            response_message=refund.response_message,
        )

    def convert_escrow_holds(records):
        for record in records:
            # We've not changed this since opening, so it should work for all past transactions.
            full_fee_amount = (record.amount * Decimal(".08")) + Money(".75", "USD")
            premium_fee_amount = record.amount * Decimal(".04") + Money(".50", "USD")
            reserve_amount = full_fee_amount - premium_fee_amount
            difference = full_fee_amount - reserve_amount
            hold_amount = record.amount - full_fee_amount
            TransactionRecord.objects.create(
                payer=record.payer,
                payee=record.escrow_for,
                status=record.status,
                source=New.CARD,
                destination=New.ESCROW,
                category=New.ESCROW_HOLD,
                content_type_id=order_type_id,
                object_id=record.object_id,
                amount=hold_amount,
                remote_id=record.txn_id,
                finalized_on=record.created_on,
                created_on=record.created_on,
                card=record.card,
                response_message=record.response_message,
            )
            TransactionRecord.objects.create(
                payer=record.payer,
                payee=None,
                source=New.CARD,
                destination=New.RESERVE,
                amount=full_fee_amount,
                content_type_id=order_type_id,
                object_id=record.object_id,
                remote_id=record.txn_id,
                response_message=record.response_message,
                status=record.status,
                category=New.SERVICE_FEE,
                card=record.card,
                finalized_on=record.created_on,
                created_on=record.created_on,
            )
            if not record.status == Old.SUCCESS:
                continue
            TransactionRecord.objects.create(
                status=New.SUCCESS,
                payer=None,
                payee=None,
                source=New.RESERVE,
                destination=New.UNPROCESSED_EARNINGS,
                remote_id=record.txn_id,
                object_id=record.object_id,
                content_type_id=order_type_id,
                amount=difference,
                card=record.card,
                response_message=record.response_message,
                created_on=record.created_on,
                finalized_on=record.created_on,
                category=New.SERVICE_FEE,
            )
            # Now we need to find if the artist got paid out.
            try:
                payout = PaymentRecord.objects.get(
                    status=Old.SUCCESS,
                    object_id=record.object_id,
                    content_type_id=order_type_id,
                    payer=None,
                    payee=record.escrow_for,
                    source=Old.ESCROW,
                )
            except PaymentRecord.DoesNotExist:
                refund = PaymentRecord.objects.filter(
                    status=Old.SUCCESS,
                    object_id=record.object_id,
                    content_type_id=order_type_id,
                    payer=None,
                    payee=record.payer,
                    source=Old.ESCROW,
                ).first()
                if refund:
                    build_refund(
                        record,
                        refund,
                        difference,
                        reserve_amount,
                        full_fee_amount,
                        hold_amount,
                    )
                continue
            else:
                fee = PaymentRecord.objects.get(
                    status=Old.SUCCESS,
                    payer=record.escrow_for,
                    payee=None,
                    source=Old.ACCOUNT,
                    object_id=record.object_id,
                    content_type_id=record.content_type_id,
                )
                # Either the fee is equal to the full amount, or it is equal to the premium fee amount.
                # If neither is true, we've fucked up and need to stop and roll back.
                equal_to_full = fee.amount == full_fee_amount
                equal_to_premium = premium_fee_amount == fee.amount
                if not (equal_to_premium or equal_to_full):
                    raise AssertionError(
                        f"Nonsense fee! Got {fee.amount}, expected {full_fee_amount} or {premium_fee_amount}!",
                    )
                part2 = TransactionRecord(
                    status=New.SUCCESS,
                    payer=None,
                    source=New.RESERVE,
                    remote_id=record.txn_id,
                    card=record.card,
                    response_message=record.response_message,
                    object_id=record.object_id,
                    content_type_id=order_type_id,
                    amount=reserve_amount,
                    created_on=payout.created_on,
                    finalized_on=payout.created_on,
                )
                if equal_to_full:
                    # We got all of the money. Send the reserve to cash holdings.
                    part2.payee = None
                    part2.destination = New.UNPROCESSED_EARNINGS
                    part2.category = New.SERVICE_FEE
                else:
                    part2.payee = record.escrow_for
                    part2.destination = New.HOLDINGS
                    part2.category = New.PREMIUM_BONUS
                part2.save()
                TransactionRecord.objects.create(
                    payer=record.escrow_for,
                    payee=record.escrow_for,
                    status=New.SUCCESS,
                    source=New.ESCROW,
                    destination=New.HOLDINGS,
                    object_id=record.object_id,
                    content_type_id=order_type_id,
                    category=New.ESCROW_RELEASE,
                    remote_id=record.txn_id,
                    card=record.card,
                    response_message=record.response_message,
                    created_on=payout.created_on,
                    finalized_on=payout.created_on,
                    amount=hold_amount,
                )

    convert_escrow_holds(
        PaymentRecord.objects.filter(
            type=Old.SALE,
            source=Old.CARD,
            payee=None,
            escrow_for__isnull=False,
            payer__isnull=False,
        ),
    )
    convert_failed_refunds(
        PaymentRecord.objects.filter(
            type=Old.REFUND, source=Old.ESCROW, status=Old.FAILURE
        )
    )
    convert_service_dues(
        PaymentRecord.objects.filter(
            type=Old.SALE,
            source=Old.CARD,
            payee=None,
            escrow_for=None,
            content_type_id=user_type_id,
        )
    )
    convert_disbursements(
        PaymentRecord.objects.filter(
            type=Old.DISBURSEMENT_SENT,
        )
    )
    convert_bank_connection_fees(
        PaymentRecord.objects.filter(
            type=Old.TRANSFER,
            payer__isnull=False,
            payee=None,
            content_type_id=bank_type_id,
        )
    )
    # Uncomment and indent when we're soon to deploy.
    # if not (settings.SANDBOX_APIS or settings.TESTING):
    #     one_time_events()


def clear_transactions(apps, schema):
    TransactionRecord = apps.get_model("sales.TransactionRecord")
    TransactionRecord.objects.all().delete()


class Migration(migrations.Migration):
    dependencies = [
        ("sales", "0055_auto_20191016_1348"),
    ]

    operations = [migrations.RunPython(run_conversion, reverse_code=clear_transactions)]
